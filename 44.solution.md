# [44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/submissions/1869029618/?envType=problem-list-v2&envId=dynamic-programming)

The goal of this problem is to implement string pattern matching with support
for the wildcard characters '?' and '*'. The '?' character matches any single
character, while the '*' character matches any sequence of characters (including
the empty sequence).

## Approach 1: Memoization

As always, wildcard matching problems can be solved using dynamic programming.
To do so, we need to clearly define the state space and the transition between
states. First, we define a function `isMatchRec(sIndex, pIndex)` that returns a
boolean indicating whether the substring `s[sIndex:]` matches the substring `p[pIndex:]`. 

```cpp
    bool isMatchRec(const string& s, const string& p, size_t si, size_t pi) {
        bool result = false;
        if (si == s.size() && pi == p.size()) {
            result = true;
        } else if (si == s.size()) {
            if (p[pi] == '*') {
                result = isMatchRec(s, p, si, pi + 1, memo);
            }
        } else if (pi == p.size()) {
            result = false;
        } else if (p[pi] == '?') {
            result = isMatchRec(s, p, si + 1, pi + 1, memo);
        } else if (p[pi] == '*') {
            for (int i = 0; !result && i < s.size() - si; ++i) {
                result = isMatchRec(s, p, si + i, pi + 1, memo);
            }
        } else {
            result = p[pi] == s[si] && isMatchRec(s, p, si + 1, pi + 1, memo);
        }

        return result;
    }
```

This function has several issues

1. It does not use memoization, which can lead to exponential time complexity due
    to overlapping subproblems.
2. The handling of the '*' character is inefficient, as it branches into $O(n)$
    subproblems. We can optimize this by considering two cases for '*':
    - The '*' matches no more characters: move to the next character in the pattern.
    - The '*' matches one more character: move to the next character in the string.

Below is the corrected implementation with memoization and optimized handling of '*'.

```cpp
    bool isMatchRec(const string& s, const string& p, size_t si, size_t pi, vector<vector<bool>>& memo) {
        if (memo[si][pi]) {
            return false;
        }

        bool result = false;
        if (si == s.size() && pi == p.size()) {
            result = true;
        } else if (si == s.size()) {
            if (p[pi] == '*') {
                result = isMatchRec(s, p, si, pi + 1, memo);
            }
        } else if (pi == p.size()) {
            result = false;
        } else if (p[pi] == '?') {
            result = isMatchRec(s, p, si + 1, pi + 1, memo);
        } else if (p[pi] == '*') {
            result = isMatchRec(s, p, si + 1, pi, memo) || isMatchRec(s, p, si, pi + 1, memo);
        } else {
            result = p[pi] == s[si] && isMatchRec(s, p, si + 1, pi + 1, memo);
        }

        if (!result) {
            memo[si][pi] = true;
        }
        return result;
    }
```

## Appraoch 2: Dynamic Programming

Usually, memoization can be converted into a bottom-up dynamic programming solution.
In this case, we can define a 2-dimensional DP table `dp` where `dp[i][j]` indicates
whether the substring `s[0:i]` matches the substring `p[0:j]`.

```cpp
    bool isMatch(string s, string p) {
        int s_len = s.size();
        p = compressPattern(p);
        int p_len = p.size();

        vector<vector<bool>> dp(s_len + 1, vector<bool>(p_len + 1, false));
        dp[0][0] = true;
        dp[0][1] = p[0] == '*';

        for (int si = 1; si <= s_len; ++si) {
            for (int pi = 1; pi <= p_len; ++pi) {
                switch (p[pi - 1]) {
                    case '?':
                        dp[si][pi] = dp[si - 1][pi - 1];
                        break;
                    case '*':
                        dp[si][pi] = dp[si - 1][pi] || dp[si][pi - 1];
                        break;
                    default:
                        dp[si][pi] = dp[si - 1][pi - 1] && s[si - 1] == p[pi - 1];
                        break;
                }
            }
        }

        return dp[s_len][p_len];
    }
```

## Approach 3: Greedy & Backtacking

A more efficient approach to solve the wildcard matching problem is to use a
greedy algorithm combined with backtracking. Let's say there is two '*' wildcards
in the pattern at positions `p1` and `p2` where `p2 > p1`. First, the greedy
approach will try to match as less characters as possible with each '*', as this
will leave more characters to be matches by the remaining pattern. So '*' does
not try to match any character at first. Once a mismatch happens, we can backtrack
to the last '*' position and try to match one more character with that '*'. Second,
when we meet another '*', we can update the last '*' position to this new position.
The reason the former '*' can be safely ignored is that the new '*' can always cover
as many characters as it needs to, providing more flexibility for future matches.

```cpp
    bool isMatch(string s, string p) {
        int s_len = s.size();
        p = compressPattern(p);
        int p_len = p.size();

        int si = 0, pi = 0;
        int s_star = -1, p_star = -1;
        while (si < s_len) {
            if (pi < p_len && (p[pi] == '?' || p[pi] == s[si])) {
                si++;
                pi++;
            } else if (pi < p_len && p[pi] == '*') {
                s_star = si;
                p_star = pi;
                pi++;
            } else {
                if (p_star == -1) return false;
                si = s_star + 1;
                pi = p_star + 1;
                s_star++;
            }
        }

        for (; pi < p_len; ++pi) {
            if (p[pi] != '*') {
                return false;
            }
        }
        return true;
    }
```
