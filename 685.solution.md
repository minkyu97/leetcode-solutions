# [Redundant Connection II](https://leetcode.com/problems/redundant-connection-ii/?envType=problem-list-v2&envId=graph)

The goal of this problem is to find a redundant directed edge in a graph that, when removed, will result in a valid rooted tree. A rooted tree is defined as a directed graph where there is exactly one node (the root) with no incoming edges, and every other node has exactly one incoming edge.

## Approach 1: DFS Cycle Detection and Parent Tracking

[code (cpp)](./685.redundant-connection-ii.cpp)
[code (python)](./685.redundant-connection-ii.py)

First, we can categorize the possible issues in the graph as follows:
1. A node has two parents (incoming edges).
2. There is a cycle in the graph.

So the possible scenarios are:
- **Case 1**: A node has two parents, and there is no cycle.
- **Case 2**: A node has two parents, and there is a cycle.
- **Case 3**: There is a cycle, but no node has two parents.

Keeping the track of parents for each node, we can identify if any node has two parents. If we find such a node, the possible scenarios are Case 1 or Case 2. If we don't find such a node, we are in Case 3.

If we find a node with two parents, but no cycle deteceted, we can simply remove the second edge that caused the two parents. If we find a cycle too, we need to check which of the two edges pointing to the same node is part of the cycle and remove that edge. We can use DFS from the root to detect the cycle.

If there is no node with two parents, we can use DFS to detect the cycle. But in this case, we don't know the root directly, and we start DFS from all the nodes until we find a cycle. Once a cycle is detected, we can remove the last edge in the cycle.

## Approach 2: Union-Find

[code (cpp)](./685.redundant-connection-ii-unionfind.cpp)

We can also use the Union-Find (Disjoint Set Union) data structure to solve this problem efficiently. The idea is to iterate through the edges to find a node with two parents and iterate again to detect cycles using union-find.

In the first pass, we track the indegree of each node. If we find a node with two parents, we just store the two edges pointing to that node and mark the second edge as invalid to skip it in the union-find process.

In the second pass, we use union-find to detect cycles. If we find a cycle and there was a node with two parents, it means the first edge causing the two parents is part of the cycle, so we return that edge. If there was no node with two parents, we return the edge last added to the cycle. If no cycle is detected, it means either  the second edge causing the two parents is part of the cycle or there is no cycle at all, so we return the second edge.
