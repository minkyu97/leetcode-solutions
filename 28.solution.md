# [28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

Given two strings `haystack` and `needle`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

## Approach 1: Brute Force

[code (cpp)](./28.find-the-index-of-the-first-occurrence-in-a-string_brute-force.cpp)

When the size of `haystack` is `m` and the size of `needle` is `n`, there are at most `m - n + 1`
possible starting positions in `haystack` where `needle` can fit. For each starting position, we check if the substring
of `haystack` matches `needle` which takes $O(n)$ time. This results in a time complexity of $O(mn)$ in the worst case.

## Approach 2: Rabin-Karp Algorithm

[code (cpp)](./28.find-the-index-of-the-first-occurrence-in-a-string_rabin-karp.cpp)

The idea behind the Rabin-Karp algorithm is to use hashing. If two strings have the different hash values,
they cannot be equal. Otherwise, we compare the strings character by character to confirm if they are actually equal.

What makes Rabin-Karp efficient is the following:
- Well-chosen hash functions can minimize the number of spurious hits (hash collisions).
- When we slide the `needle` over `haystack`, we can compute the hash value of the new substring in constant time using rolling hash.

In our implementation, we use a base of 26 (number of lowercase English letters) and a large prime modulus (1e9 + 7) to overcome overflow and reduce collisions.
The time complexity of this approach is $O(m + n)$ on average, where `m` is the length of `haystack` and `n` is the length of `needle`. However, in the worst case (due to hash collisions), it can degrade to $O(mn)$, which is uncommon in practice.

### Double Hashing

[code (cpp)](./28.find-the-index-of-the-first-occurrence-in-a-string_rabin-karp-double-hash.cpp)

To further reduce the probability of hash collisions, we can use double hashing. This involves computing
two different hash values for the same substring using different bases and moduli. A match is only considered valid if both hash values match.

## Approach 3: Knuth-Morris-Pratt (KMP) Algorithm

[code (cpp)](./28.find-the-index-of-the-first-occurrence-in-a-string_kmp.cpp)

The Knuth-Morris-Pratt (KMP) algorithm computes a longest prefix-suffix (LPS) array that is used to skip unnecessary comparisons in the `haystack` when a mismatch occurs.
Let's say `needle[:k]` match with `haystack[i - k + 1:i]`. If there is a mismatch at `needle[k]` and `haystack[i + 1]`, 
we can use the LPS array to determine the next position in `needle` to compare with `haystack[i + 1]`, instead of starting over from the beginning of `needle`.

But how does it work? Let's say there is a certain integer `p < k` such that and `needle[:p]` are the same as `haystack[i - p + 1:i]`.
Then we can skip the first `k - p` characters and check from `needle[p]` with `haystack[i + 1]`. Since we've already shown that `needle[:k]` matches with `haystack[i - k + 1:i]`, we know that `needle[:p]` matches with `needle[k - p:k]` (as they both match with `haystack[i - p + 1:i]`). The largest such `p` is stored in the LPS array at index `k - 1`.
The time complexity of the KMP algorithm in the worst case is $O(m + n)$, where building LPS takes $O(m)$ time and searching takes $O(n)$ time.